# Assignment 3

## 1 Unit Testing

### Documentation

The tests are written using Python's pytest framework, which had to be installed using `pip3 install pytest` in the terminal. For viewing the test coverage, the addition to pytest was installed using `pip3 install pytest-cov`.

#### test_assembler.py

- **Purpose**: The purpose of the `test_assembler.py` file is to validate the funcionality of the `assembler.py` program, which can be found in the `debugger` and `vm` folder. the assembler converts assembly language instruction (found in folder `exercise_1/assemblyPrograms`) into machine code (found in folder `exercise_1/vmInstructions`). The test in the `test_assembler.py` file ensure that the conversion is correct by targeting each assembly program with a specific test function.

- **subprocess**: All functions first generate the corresponding `.mx` file, because the test need to ensure that the values in those `.mx` files, which were generated by the assembler, are correct.

- **basic_operation_program (basicOp)**: This test function tests the assembler if it correctly translated the basic arithemetic `virtual machine op-codes` from the assembly program found in `exercise_1/assemblyPrograms/basicOp.as` to the virtual machine instructions found in `exercise_1/vmInstructions/basicOp.mx`. The values in the `.mx` file are then compared to the calculated values in the variable `expected_output`.

- **print_memory_program (copyPrntMem)**: This test function tests the assembler if it correctly translated the print and memory `virtual machine op-codes` from the assembly program found in `exercise_1/assemblyPrograms/copyPrntMem.as` to the virtual machine instructions found in `exercise_1/vmInstructions/copyPrntMem.mx`. The values in the `.mx` file are then compared to the calculated values in the variable `expected_output`.

- **memory_operations_branch_equal_program (memOpBeq)**: This test function tests the assembler if it correctly translated the memory and branch equal `virtual machine op-codes` from the assembly program found in `exercise_1/assemblyPrograms/memOpBeq.as` to the virtual machine instructions found in `exercise_1/vmInstructions/memOpBeq.mx`. The values in the `.mx` file are then compared to the calculated values in the variable `expected_output`.

- **memory_operations_branch_notEqual_program (memOpBne)**: This test function tests the assembler if it correctly translated the memory and branch not equal `virtual machine op-codes` from the assembly program found in `exercise_1/assemblyPrograms/memOpBne.as` to the virtual machine instructions found in `exercise_1/vmInstructions/memOpBne.mx`. The values in the `.mx` file are then compared to the calculated values in the variable `expected_output`.

With these test, it is ensured that **all 11** `virtual machine op-codes` were correctly translated by the assembler.

#### test_vm.py

### Decisions Taken

**Simulate Terminal Input**

- **subprocess**: The task stated that each `.as` file had to be run through the assembler for creating its corresponding `.mx` file. Therefore the module `subprocess` was used, to simulate the terminal input for generating the corresponding `.mx` files by the assembler.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

## 2 Disassembler

#### Documentation

- **Example**: example text: `example function`.

#### Decisions Taken

**Example**

- example text: `example function`.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

## 3 New Features and Problems - Assembler

### 3.1 Increment and Decrement

#### Documentation

- **Example**: example text: `example function`.
- **inc and dec**: with the instructions inc and dec a register can be increased or decreased by 1. Example syntax: `inc R0`, `dec R0`

#### Decisions Taken

**Added operations to running while loop im vm.py**

- example text: `example function`.
- To ensure the functionality of the extended architecture relevant elif clauses were added to `vm.py` in the while running clause.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python assembler.py ../exercise_3/example_3_1.as ../exercise_3/output_3_1.mx python vm.py ../exercise_3/output_3_1.mx -`
- To run the programm in `example_3_1.as` run the following command in the terminal in the vm/ directory: `python assembler.py ../exercise_3/example_3_1.as ../exercise_3/output_3_1.mx python vm.py ../exercise_3/output_3_1.mx -`

### 3.2 Swap values

#### Documentation

- **Example**: example text: `example function`.
- **swp**: with the instruction swp two registers will swap values. Syntax is as follows: `swp R1 R2`.

#### Decisions Taken

**Use of temporary variable**

- example text: `example function`.
- In the while running loop in `vm.py` a temporary variable is used to swap the values.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`
- To run the programm in `example_3_2.as` run the following command in the terminal in the vm/ directory: `python assembler.py ../exercise_3/example_3_2.as ../exercise_3/output_3_2.mx python vm.py ../exercise_3/output_3_2.mx -`

### 3.3 Reverse Array in Place

#### Documentation

- **Example**: example text: `example function`.
- **div**: This instruction divides the value of a register by two and applies the Math.floor() function to it -> rounds it to the next lower integer. Syntax: `div R0`

- **example_3_3.as**: The array [1, 2, 3, 4, 5] gets created at line 35 in memory. Then a loop gets executed to reverse that array. After the program is finished, the reversed array can be found at line 35 in memory. The loop also works with different arrays. To achieve this the user can change the array base address, array length and load a different array into the memeory before the loop.

#### Decisions Taken

**div**

- This instruction is needed to get the limit of how many times array elements must be exchanged. We could have also introduced an instruction that branches if two register are eqal or the second is smaller than the first register to solve this problem. But we decided to use this div option instead, because one would need to pass 3 registers for the branching solution and that would have needed more changes in the architecture and the assambler.

**Additional registers**

- example text: `example function`.
- Additional registers were added in the `NUM_REG` property of `architecture.py` because they are needed to keep track of all variables in the programm.

**Loop**

- In order to reverse the array in place a loop is used. The loop counts down from the floored half array length. This is because it needs that many exchanges to reverse the array. Each time the loop is executed, two values at the addresses R4 and R5 (which represent in the first time the loop is executed the `array base address` and `array end address`) are loaded into the two temporary variables R2 and R3. Then R2 is saved at address R5 and R3 is saved at R4, so the values get exchanged. Then R4 is increased by one and R5 is decreased by one. Finally the index R1 is decresed by one. When R1 reaches 0 all array values will have gotten exchanged and the loop will end.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`
- To run the programm in `example_3_3.as` run the following command in the terminal in the vm/ directory: `python assembler.py ../exercise_3/example_3_3.as ../exercise_3/output_3_3.mx python vm.py ../exercise_3/output_3_3.mx -`

## 4 New features - Debugger

### 4.1 Show Memory Range

#### Documentation

- **Example**: example text: `example function`.

#### Decisions Taken

**Example**

- example text: `example function`.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

### 4.2 Breakpoint Addresses

#### Documentation

- **Example**: example text: `example function`.

#### Decisions Taken

**Example**

- example text: `example function`.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

### 4.3 Command Completion

#### Documentation

- **Example**: example text: `example function`.

#### Decisions Taken

**Example**

- example text: `example function`.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

### 4.4 Watchpoints

#### Documentation

- **Example**: example text: `example function`.

#### Decisions Taken

**Example**

- example text: `example function`.

#### Execution

- the following line has to be executed in the terminal for the code to work with the LGL: `python`

Task 3 execution:
inside vm folder run:

python assembler.py ../exercise_3/example_3_2.as ../exercise_3/output_3_2.mx
python vm.py ../exercise_3/output_3_2.mx -

python assembler.py ../exercise_3/example_3_3.as ../exercise_3/output_3_3.mx
python vm.py ../exercise_3/output_3_3.mx -

- the following line has to be executed in the terminal for the code to work with the LGL: `python`
